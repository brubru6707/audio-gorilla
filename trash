include shared-gdrive("funword-definitions.arr", "1EiTAb-zUNlHnm1prEdAldQ-IYp3RxrbU")

provide: words-for end

include my-gdrive("funword-common.arr")
# END HEADER
# DO NOT CHANGE ANYTHING ABOVE THIS LINE
#
# You may write implementation-specific tests (e.g., of helper functions) in this file.
import sets as S
include lists
include string-dict

keypad = [string-dict: "2", "abc", "3", "def", "4", "ghi", "5", "jkl", "6", "mno", "7", "pqrs", "8", "tuv", "9", "wxyz"]

data Pos-Dgt:
    pos-dgt(pos, dgt)
end

data Indx-Wrd:
    indx-wrd(indx, wrd)
end

data Updated-Remaining:
    udpated-remaining(abs-indx, updated, remaining)
end

# [list: indx-wrd(0, "abg"), indx-wrd(0, "yo")]
fun trn-remaining-into-combo(remaining :: List<Indx-Dgt>):
  doc: "This turns a list of indx-wrd into a string"
  ltr-remaining = remaining.map(lam(e): 
      string-char-at(e.wrd, e.indx)
    end)
  ltr-remaining.fold(lam(acc, e): 
      acc + e
    end, "")
where: 
  remaining-1 = [list: indx-wrd(1, "abg")]
  trn-remaining-into-combo(remaining-1) is "b"
  remaining-2 = remaining-1.append([list: inx-wrd(2, "hithere")])
  trn-remaining-into-combo(remaining-2) is "bt"
end

fun compute-combinations(remaining::List<Indx-Dgt>):
  doc: "This computes all the possible combinations based on the keypad values and puts it in a list"
  init-combo = trn-remaining-into-combo(remaining)
  updated-remaining-output = fold(lam(acc, e): 
      if (acc.updated <> true) and ((e.indx - 1) <> wrd.length()):
        remaining-updated-lst= remaining.set(acc.abs-index, indx-wrd(e.indx + 1, e.wrd))
        updated-remaining(true, remaining-updated-lst)
      else
        updated-remaining(acc.abs-indx + 1, acc.updated, remaining)
      end
    end, udpated-remaining(0, false, remaining), remaining)
  if udpated-remaining-output.updated == true:
    computed-combo = trn-remaining-into-combo(compute-combinations(ltr-indx-lst, remaining).remaining)
    [list: init-combo] + [list: computed-combo]
  else:
    [list: init-combo] + [list: ""]
  end
end

fun combinations(digits :: String):
  doc: "Takes in the digits and computes the posisble combinations"
  # digits will be like "234"
  remaining = string-split-all(digits).fold(lam(acc, e): 
      acc.append([list: pos-dgt(0, keypad.get-value(e))])
    end, [list: ])
  S.list-to-list-set(compute-combinations(remaining))
end

fun words-for(num-digits :: Number) -> StringDict<S.Set<String>>:
  strt-nm = string-to-number(fold(lam(acc, e):
        acc + num-to-string(e)
      end, "", range(2, num-digits + 2))).value
  nd-nm = string-to-number(fold(lam(acc, e): 
        acc + num-to-string(e)
      end, "" , range(10 - num-digits, 10).reverse())).value
  al-ky-vals = range(str-nm, mx-nm + 1).filter(lam(e): 
      (S.list-to-list-set((string-split-all(string-to-number(e), ""))).length() == num-digits) and (string-split-all(string-to-number(e), "").member([list: "1"])) # gets rid of duplicate numbers + ignores 1
    end)
  # time to set a mutable string dict
  nms-nd-combos = fold(lam(acc, ky):
      # ky is like "342"
      acc.set(num-to-string(ky), combinations(ky))
    end, [string-dict: ], al-ky-vals)
end

# Provided word list
print(WORD-LIST-1000)